//data structure of each node
struct node {
    ll value;
    // change this constructor acc to the question
    node() {
        value = INT_MAX;
    }
};

class SGTree {
public:
    vector<node> seg;
    // size of the vector
    SGTree(ll n) {
        seg.resize(4 * n + 5);
    }
    // merging logic, fill this
    node merge(node a, node b) {
        node c;
        c.value = min(a.value,b.value);
        return c;
    }
    // build(0,0,n-1,arr) always
    void build(ll idx, ll low, ll high, vector<ll> &arr) {
        if (low == high) {
            seg[idx].value = arr[low];
            return;
        }
        ll mid = low + (high - low) / 2;
        build(idx * 2 + 1, low, mid, arr);
        build(idx * 2 + 2, mid + 1, high, arr);
        seg[idx] = merge(seg[idx * 2 + 1], seg[idx * 2 + 2]);
    }
    // query(0,0,n-1,leftRange,rightRange)
    node query(ll idx, ll low, ll high, ll l, ll r) {
        if (l > high || r < low) return node();  
        if (low >= l && high <= r) return seg[idx];
        ll mid = low + (high - low) / 2;
        node lh = query(idx * 2 + 1, low, mid, l, r);
        node rh = query(idx * 2 + 2, mid + 1, high, l, r);
        return merge(lh, rh);
    }
    //update (0,0,n-1,positon,updatedValue)
    void update(ll idx, ll low, ll high, ll i, ll val) {
        if (i < low || i > high) return;  // add bounds check here
        if (low == high) {
            seg[idx].value = val;
            return;
        }
        ll mid = low + (high - low) / 2;
        update(2 * idx + 1, low, mid, i, val);
        update(2 * idx + 2, mid + 1, high, i, val);
        seg[idx] = merge(seg[2 * idx + 1], seg[2 * idx + 2]);
    }
};
